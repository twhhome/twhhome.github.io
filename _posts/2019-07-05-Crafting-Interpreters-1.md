---
layout:     post                    # 使用的布局（不需要改）
title:      Crafting Interpreters 读书笔记(1)               # 标题 
date:       2019-07-05              # 时间
author:     twhhome                      # 作者
header-img: img/post-bg-crafting-interpreters-1.png    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签

    - Java
    - C++
    - Interpreter
---

「Crafting Interpreters」本书地址：[Crafting Interpreters](http://www.craftinginterpreters.com)

# 「Crafting Interpreters」本书介绍

「Crafting Interpreters」是一本关于创造编程语言的书，它包含了你实现一个全功能，高效的脚本语言所需要的所有东西。你会学到有关语法解析和语义学的高级概念，以及一些细节例如字节码表示和垃圾回收。「Crafting Interpreters」会建立一个叫Lox的语言，并教你如何用Java和C++来写这个语言的解释器。

# 语言的组成

下面是一张有关语言解释器的图：
![5d1eabcbb25a530322](https://i.loli.net/2019/07/05/5d1eabcbb25a530322.png)
以下面一段代码为例：
![5d1eacb32910a53623](https://i.loli.net/2019/07/05/5d1eacb32910a53623.png)

### Scanning(扫描)

第一步是扫描。一个扫描器接受线性的字符流，然后把它们组合成一系列类似于“单词”的东西。在编程里，这样的每个单词叫做一个**token**。有些**token**是单个字符，例如 *(* 和 *,* ，其他的可能是多个字符组成，例如数字( *123* )，字符串文字( *"hi!"* )，和标识符( *min* )。
在源文件里一些字符实际上不代表任何东西。扫描器通常丢弃空格和注释，留下一系列有意义的**token**。
![5d1eb0e0d2a9082171](https://i.loli.net/2019/07/05/5d1eb0e0d2a9082171.png)

### Parsing(解析)

下一步是解析。解析器接受一串**token**，然后建立一个与语法的嵌套性质相对应的树形结构。这些树有不同的名字：**解析树(parse tree)**或者**抽象语法树(abstract syntax tree)**。
![5d1ebaaff23d436874](https://i.loli.net/2019/07/05/5d1ebaaff23d436874.png)

### Static analysis(静态分析)

在一个表达式例如a + b，我们知道我们要把a和b加起来，但是我们不知道这些名字指向哪里。它们是局部变量吗？还是全局变量？它们在哪里被定义？
大多数语言所做的第一点分析被称为**绑定(binding)**或**解析(resolution)**。对于每个**标识符(identifier)**，我们找到那个名字在哪里被定义，然后把它们两个连在一起。
一旦我们知道a和b在哪里被定义，我们也可以知道它们的类型。如果这些类型不支持相互加起来，那我们会报告一个**类型错误(type error)**。

### Intermediate representations(中级形式)

你可以把编译器看作是一个管道，管道的每个阶段的工作就是把代码整理成一种使下一阶段更容易实现的方式。管道的前端特定于用户编程的语言，后端与代码将运行的最终结构有关。
在中间，代码可能以某种**中间形式(intermediate representation, IR)**被储存，这种中间形式与源形式和最终形式都不是紧密捆绑在一起的，而是作为这两种语言的接口。
这样可以让你以更少的精力来支持多种源语言和目标平台。例如，你想要实现一个支持Pascal,C和Fortran语言的编译器，并且目标平台包含x86,ARM和I dunno。通常来说，这意味着你需要9个完全的编译器：Pascal->x86,C->ARM和其他组合。
一个共享的中级形势可以大大减少上述的工作。你为每一个语言写一个产生IR的前端，然后为每个目标平台写一个后端。现在你可以通过混合和配对来得到每种组合。

### Optimization(优化)

一旦我们懂得用户的程序要做什么，我们就可以用一个不同的含有相同语义但是更高效的程序来替换它。我们可以进行优化。
一个简单的例子是常数替换：
`pennyArea = 3.14159 * (0.75 / 2) * (0.75 / 2);`
我们可以做如下替换：
`pennyArea = 0.4417860938;`

### Code generation(代码生成)

最后一步是把用户代码转换成机器可以运行的形式，换言之就是**代码生成(code generation)**，这里所说的代码指的是机器运行的代码，例如CPU的指令等。

# 编译器(Compiler)和解释器(Interpreter)

* 当我们说一个语言实现是一个编译器，那它就是把源代码转换成另一种形式但不执行它。用户必须自己运行编译的结果。
* 相反地，当我们说一个语言实现是一个解释器，那它就是接受源代码然后立即执行它。它从源代码处运行程序。

一些语言实现很显然是编译器和不是编译器。GCC和Clang接受你的C代码然后把它编译成机器代码。用户直接运行它，并且可能不知道是用什么工具来编译的。所以这些称为C语言的编译器。
![5d1ec6883b5c123437](https://i.loli.net/2019/07/05/5d1ec6883b5c123437.png)
